学习笔记
自我思维培养：
0.做-倒逼(不管怎么样，计算机的题解就在那里)
1.沟通时不重复提及
2.拒绝复杂化先入为主
3.代码要写出来，运行调试出来，画动态图
4.通过多遍来感知痛点，必须突破
5.提高工作和学习效率（必须提高刷题速率，要达到30分钟刷一题，不要alliN时间，否则会形成惰性，因为这个习惯长期坚持的话不能超过30分钟，需要将时间投入下个训练，每个阶段一个主要训练）
6.如果程序员在接受一次沟通，2秒内反应不过来的话，一定是陌生的，所以需要提醒自己保持激情。
7.一周第一天总结这周要学的算法理论，归档，然后每天刷题来强化修正这个理论，否则刷了一周理论被自己搞成题海战术了（为了做题而做题，其实做题是为了初步对数据结构与算法基本掌握而不是越刷越杂越乱----入门1-入门2-入门3-不断提出不断计划的迭代提高---入门和苦练苦练苦练----10本算法书代码彻底精通算法）。
# 学习笔记 Week06

## 动态规划 (Dynamic Programming 动态递推)

使用一种递归的方式将一个复杂的问题，分解成简单的子问题

采用分治+最优子结构（Optimal substructure）的思想

### 和递归分治的区别和共同点

动态规划和递归或者分治没有本质上的区别

* 共性
  * 寻找重复子问题
* 差别
  * 动态规划有最优子结构
  * 动态规划中途可以淘汰次优解（如果不淘汰，复杂度一般是指数级；如果进行淘汰会优化成O(n^2)或者O(n)的复杂度）
  
### 关键点

* 最优子结构-1
  * opt[n]=best_of(opt[n-1],opt[n-2],...)
* 存储中间状态
  * opt[i]
* 递推公式(状态转移方程或者DP方程)
  * Fib: opt[i] = opt[n-1] + opt[n-2]

### 麻省理工五步法

* 进行分治把复杂问题转化成简单重复子问题（define subproblems）
* 猜递推方程（guess part of solution）
* 合并子问题的解（relate subproblem solutions）
* 递归&记忆化或自底向上建立DP状态表（recurse&memories or build DP table bottom-uo）
* 解决原问题（solve original problem）

## 思维小结

* 打破自己的思维惯性，形成机器思维（找重复性）
* 理解复杂逻辑的关键
* 也是职业进阶的要点要领（不要人肉递归，不要亲力亲为）
